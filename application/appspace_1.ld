/*
STM32G0 Bootloader
Jonah Swain [SWNJON003]

Application space 1 sections/linker file

Adapted in part from the linker script auto-generated by STM32CubeIDE for the STM32G071RB
ST's linker script is licensed by ST under the BSD 3-clause license (opensource.org/licenses/BSD-3-Clause)
*/

/* Include memory map from memory_map.ld */
INCLUDE memory_map.ld

/* Program entry point */
ENTRY(Reset_Handler)

/* Minimum stack and heap section size configuration */
_MIN_STACK_SIZE = 1K;
_MIN_HEAP_SIZE = 512;

/* Stack initial address (end of data memory) */
__STACK_END = ORIGIN(SRAM) + LENGTH(SRAM);

/* Sections */
SECTIONS
{
    /* Vector table at start of program memory */
    .isr_vector :
    {
        . = ALIGN(4);
        KEEP(*(.isr_vector))
        . = ALIGN(4);
    } >FLASH_APP1

    /* Application code after vector table in program memory */
    .text :
    {
        . = ALIGN(4);
        *(.text)
        *(.text*)
        *(.glue_7)
        *(.glue_7t)
        *(.eh_frame)
        KEEP(*(.init))
        KEEP(*(.fini))
        . = ALIGN(4);
        __APPLICATION_TEXT_END = .; /* Global symbol for end of application .text (code) section */
    } >FLASH_APP1

    /* Application constant/read-only data in program memory */
    .rodata :
    {
        . = ALIGN(4);
        *(.rodata)
        *(.rodata*)
        . = ALIGN(4);
        __APPLICATION_RODATA_END = .; /* Global symbol for end of application .rodata (data) section */
    } >FLASH_APP1

    /* ARM unwinding sections in program memory */
    .ARM.extab :
    { 
        . = ALIGN(4);
        *(.ARM.extab* .gnu.linkonce.armextab.*)
        . = ALIGN(4);
    } >FLASH_APP1
  
    .ARM :
    {
        . = ALIGN(4);
        __exidx_start = .;
        *(.ARM.exidx*)
        __exidx_end = .;
        . = ALIGN(4);
    } >FLASH_APP1

    /* C/C++ object/section initialisation and deinitialisation code in program memory */
    .preinit_array :
    {
        . = ALIGN(4);
        PROVIDE_HIDDEN (__preinit_array_start = .);
        KEEP (*(.preinit_array*))
        PROVIDE_HIDDEN (__preinit_array_end = .);
        . = ALIGN(4);
    } >FLASH_APP1
    
    .init_array :
    {
        . = ALIGN(4);
        PROVIDE_HIDDEN (__init_array_start = .);
        KEEP (*(SORT(.init_array.*)))
        KEEP (*(.init_array*))
        PROVIDE_HIDDEN (__init_array_end = .);
        . = ALIGN(4);
    } >FLASH_APP1
    
    .fini_array :
    {
        . = ALIGN(4);
        PROVIDE_HIDDEN (__fini_array_start = .);
        KEEP (*(SORT(.fini_array.*)))
        KEEP (*(.fini_array*))
        PROVIDE_HIDDEN (__fini_array_end = .);
        . = ALIGN(4);
    } >FLASH_APP1

    __APPLICATION_DATA_ADDR = LOADADDR(.data); /* Global symbol for load address of application .data (data) section */

    /* Initialised data/variables in data memory loaded from program memory */
    .data :
    {
        . = ALIGN(4);
        __APPLICATION_DATA_START = .; /* Global symbol for start of application .data (data) section */
        *(.data)
        *(.data*)

        . = ALIGN(4);
        __APPLICATION_DATA_END = .; /* Global symbol for end of application .data (data) section */
    } >SRAM AT> FLASH_APP1

    /* Uninitialised data/variables in data memory */
    .bss :
    {
        . = ALIGN(4);
        __APPLICATION_BSS_START = .; /* Global symbol for start of application .bss (uninitialised data) section */
        *(.bss)
        *(.bss*)
        *(COMMON)

        . = ALIGN(4);
        __APPLICATION_BSS_END = .; /* Global symbol for end of application .bss (uninitialised data) section */
    } >SRAM

    /* User-mode heap and stack in data memory (checks that sufficient SRAM is available) */
    ._user_heap_stack :
    {
        . = ALIGN(8);
        PROVIDE ( end = . );
        PROVIDE ( _end = . );
        . = . + _MIN_HEAP_SIZE;
        . = . + _MIN_STACK_SIZE;
        . = ALIGN(8);
    } >SRAM

    /* Discard information from compiler libraries */
    /DISCARD/ :
    {
        libc.a ( * )
        libm.a ( * )
        libgcc.a ( * )
    }

    .ARM.attributes 0 : { *(.ARM.attributes) }
}