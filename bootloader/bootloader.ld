/*
STM32G0 Bootloader
Jonah Swain [SWNJON003]

Bootloader sections/linker file

Adapted in part from the linker script auto-generated by STM32CubeIDE for the STM32G071RB
ST's linker script is licensed by ST under the BSD 3-clause license (opensource.org/licenses/BSD-3-Clause)
*/

/* Include memory map from memory_map.ld */
INCLUDE memory_map.ld

/* Program entry point */
ENTRY(Reset_Handler)

/* Minimum stack and heap section size configuration */
_MIN_STACK_SIZE = 1K;
_MIN_HEAP_SIZE = 512;

/* Stack initial address (end of data memory) */
__STACK_END = ORIGIN(SRAM) + LENGTH(SRAM);

/* Sections */
SECTIONS
{
    /* Vector table at start of program memory */
    .isr_vector :
    {
        . = ALIGN(4);
        KEEP(*(.isr_vector))
        . = ALIGN(4);
    } >FLASH_BL_CORE

    /* Bootloader code after vector table in program memory */
    .text :
    {
        . = ALIGN(4);
        *(.text)
        *(.text*)
        *(.glue_7)
        *(.glue_7t)
        *(.eh_frame)
        KEEP(*(.init))
        KEEP(*(.fini))
        . = ALIGN(4);
        __BL_TEXT_END = .; /* Global symbol for end of bootloader .text (code) section */
    } >FLASH_BL_CORE

    /* Bootloader constant/read-only data in program memory */
    .rodata :
    {
        . = ALIGN(4);
        *(.rodata)
        *(.rodata*)
        . = ALIGN(4);
        __BL_RODATA_END = .; /* Global symbol for end of bootloader .rodata (data) section */
    } >FLASH_BL_CORE

    /* ARM unwinding sections in program memory */
    .ARM.extab :
    { 
        . = ALIGN(4);
        *(.ARM.extab* .gnu.linkonce.armextab.*)
        . = ALIGN(4);
    } >FLASH_BL_CORE
  
    .ARM :
    {
        . = ALIGN(4);
        __exidx_start = .;
        *(.ARM.exidx*)
        __exidx_end = .;
        . = ALIGN(4);
    } >FLASH_BL_CORE

    /* C/C++ object/section initialisation and deinitialisation code in program memory */
    .preinit_array :
    {
        . = ALIGN(4);
        PROVIDE_HIDDEN (__preinit_array_start = .);
        KEEP (*(.preinit_array*))
        PROVIDE_HIDDEN (__preinit_array_end = .);
        . = ALIGN(4);
    } >FLASH_BL_CORE
    
    .init_array :
    {
        . = ALIGN(4);
        PROVIDE_HIDDEN (__init_array_start = .);
        KEEP (*(SORT(.init_array.*)))
        KEEP (*(.init_array*))
        PROVIDE_HIDDEN (__init_array_end = .);
        . = ALIGN(4);
    } >FLASH_BL_CORE
    
    .fini_array :
    {
        . = ALIGN(4);
        PROVIDE_HIDDEN (__fini_array_start = .);
        KEEP (*(SORT(.fini_array.*)))
        KEEP (*(.fini_array*))
        PROVIDE_HIDDEN (__fini_array_end = .);
        . = ALIGN(4);
    } >FLASH_BL_CORE

    __BL_DATA_ADDR = LOADADDR(.data); /* Global symbol for load address of bootloader .data (data) section */

    /* Initialised data/variables in data memory loaded from program memory */
    .data :
    {
        . = ALIGN(4);
        __BL_DATA_START = .; /* Global symbol for start of bootloader .data (data) section */
        *(.data)
        *(.data*)

        . = ALIGN(4);
        __BL_DATA_END = .; /* Global symbol for end of bootloader .data (data) section */
    } >SRAM AT> FLASH_BL_CORE

    /* Uninitialised data/variables in data memory */
    .bss :
    {
        . = ALIGN(4);
        __BL_BSS_START = .; /* Global symbol for start of bootloader .bss (uninitialised data) section */
        *(.bss)
        *(.bss*)
        *(COMMON)

        . = ALIGN(4);
        __BL_BSS_END = .; /* Global symbol for end of bootloader .bss (uninitialised data) section */
    } >SRAM

    /* User-mode heap and stack in data memory (checks that sufficient SRAM is available) */
    ._user_heap_stack :
    {
        . = ALIGN(8);
        PROVIDE ( end = . );
        PROVIDE ( _end = . );
        . = . + _MIN_HEAP_SIZE;
        . = . + _MIN_STACK_SIZE;
        . = ALIGN(8);
    } >SRAM

    /* bootloader_common function dispatch table near the end of bootloader program memory (256 bytes from end) */
    .dispatch_table __FLASH_BL_CORE_START + __FLASH_BL_CORE_LEN - 0x100 :
    {
        KEEP(*(.dispatch_table))
    } >FLASH_BL_CORE

    /* Discard information from compiler libraries */
    /DISCARD/ :
    {
        libc.a ( * )
        libm.a ( * )
        libgcc.a ( * )
    }

    .ARM.attributes 0 : { *(.ARM.attributes) }
}